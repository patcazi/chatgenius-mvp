<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Chatgenie Client</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet" />
  </head>
  <body class="bg-light">
    <div class="container py-5">
      <h1 class="text-center mb-4">Chatgenie Client</h1>
      <p id="status" class="text-danger text-center">Not connected</p>

      <!-- Chat Section -->
      <div class="card mb-4">
        <div class="card-body">
          <h2>Chat</h2>
          <div id="chatLog" class="border p-3 mb-3" style="height: 300px; overflow-y: auto;"></div>
          <div class="input-group">
            <input id="messageInput" type="text" class="form-control" placeholder="Type a message..." maxlength="1000" />
            <button id="sendMessageBtn" class="btn btn-primary" disabled>Send</button>
          </div>
          <small class="text-muted">Maximum message length: 1000 characters</small>
        </div>
      </div>

      <!-- Login Section -->
      <div class="card mb-4" id="loginCard">
        <div class="card-body">
          <h2>Login</h2>
          <form id="loginForm" novalidate>
            <div class="mb-3">
              <input id="loginUsername" type="text" class="form-control" placeholder="Username" required />
              <div class="invalid-feedback">Username is required</div>
            </div>
            <div class="mb-3">
              <input id="loginPassword" type="password" class="form-control" placeholder="Password" 
                     minlength="8" required />
              <div class="invalid-feedback">Password must be at least 8 characters</div>
            </div>
            <button id="loginButton" type="submit" class="btn btn-primary w-100">Login</button>
          </form>
          <div id="loginResult" class="alert mt-3" role="alert" style="display: none;"></div>
        </div>
      </div>

      <!-- Channels Section -->
      <div class="card mb-4">
        <div class="card-body">
          <h3>Channels</h3>
          <div class="input-group mb-3">
            <input id="channelInput" type="text" class="form-control" placeholder="Channel name..." />
            <button id="joinChannelBtn" class="btn btn-success" disabled>Join Channel</button>
          </div>
          <p id="currentChannel" class="text-muted">Not in any channel</p>
        </div>
      </div>

      <!-- Online Users -->
      <div class="card mb-4">
        <div class="card-body">
          <h3>Online Users</h3>
          <ul id="onlineUsersList" class="list-group"></ul>
        </div>
      </div>

      <!-- Private Message Section -->
      <div class="card mb-4">
        <div class="card-body">
          <h3>Private Messages</h3>
          
          <!-- Private Chat Interface (Hidden by default) -->
          <div id="privateChatInterface" style="display: none;">
            <div class="d-flex justify-content-between align-items-center mb-3">
              <h4 id="privateChatHeader" class="m-0">Chat with: </h4>
              <button id="closePrivateChat" class="btn btn-sm btn-outline-secondary">Close Chat</button>
            </div>
            <div id="privateChatLog" class="border p-3 mb-3" style="height: 200px; overflow-y: auto;"></div>
            <div class="input-group">
              <input id="privateMessageInput" type="text" class="form-control" placeholder="Type private message..." maxlength="1000" />
              <button id="sendPrivateMessageBtn" class="btn btn-primary">Send</button>
            </div>
          </div>

          <!-- Start New Private Chat Interface -->
          <div id="startPrivateChatInterface">
            <div class="input-group mb-3">
              <input id="privateMessageUser" type="text" class="form-control" placeholder="Username to message..." />
              <button id="startPrivateMessageBtn" class="btn btn-info" disabled>Start Chat</button>
            </div>
            <p id="privateMessageStatus" class="text-muted"></p>
          </div>
        </div>
      </div>

      <!-- File Upload Section -->
      <div class="card mb-4">
        <div class="card-body">
          <h3>File Upload</h3>
          <form id="fileUploadForm">
            <div class="mb-3">
              <label for="fileInput" class="form-label">Upload File (Max 5MB):</label>
              <input type="file" id="fileInput" class="form-control" accept="image/*,.pdf" />
              <small class="text-muted d-block">Allowed types: Images, PDF</small>
            </div>
            <button type="submit" class="btn btn-warning w-100" disabled>Upload</button>
          </form>
          <div id="uploadStatus" class="alert mt-3" style="display: none;"></div>
          <div id="fileLinks" class="mt-4">
            <h4>Uploaded Files:</h4>
            <ul class="list-group" id="filesList"></ul>
          </div>
        </div>
      </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      // Global state
      let currentUser = null;
      let currentRoom = null;
      let authToken = null;

      // Socket.IO setup with auth
      const socket = io({
        auth: (cb) => {
          cb({ token: authToken });
        }
      });

      // DOM Elements
      const statusEl = document.getElementById('status');
      const messageInput = document.getElementById('messageInput');
      const sendMessageBtn = document.getElementById('sendMessageBtn');
      const chatLog = document.getElementById('chatLog');
      const loginForm = document.getElementById('loginForm');
      const loginResult = document.getElementById('loginResult');
      const channelInput = document.getElementById('channelInput');
      const joinChannelBtn = document.getElementById('joinChannelBtn');
      const currentChannelEl = document.getElementById('currentChannel');
      const fileUploadForm = document.getElementById('fileUploadForm');
      const uploadStatus = document.getElementById('uploadStatus');
      const filesList = document.getElementById('filesList');

      // Socket connection handlers
      socket.on('connect', () => {
        statusEl.textContent = 'Connected';
        statusEl.className = 'text-success text-center';
        
        // Restore session if we have auth token
        if (authToken) {
          socket.emit('setUsername', currentUser?.username);
        }
      });

      socket.on('disconnect', () => {
        statusEl.textContent = 'Disconnected';
        statusEl.className = 'text-danger text-center';
      });

      // Message display helper
      function appendMessage(message, type = 'normal') {
        const p = document.createElement('p');
        p.textContent = message;
        p.className = type === 'error' ? 'text-danger' : 'mb-1';
        chatLog.appendChild(p);
        chatLog.scrollTop = chatLog.scrollHeight;
      }

      // Show status helper
      function showStatus(element, message, type) {
        element.textContent = message;
        element.className = `alert alert-${type}`;
        element.style.display = 'block';
        setTimeout(() => {
          element.style.display = 'none';
        }, 5000);
      }

      // Login form handler
      loginForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const username = document.getElementById('loginUsername').value.trim();
        const password = document.getElementById('loginPassword').value;
        
        if (!username || !password) {
          loginForm.classList.add('was-validated');
          return;
        }

        const loginButton = document.getElementById('loginButton');
        loginButton.disabled = true;

        try {
          const response = await fetch('/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password })
          });

          const data = await response.json();

          if (response.ok) {
            authToken = data.token;
            currentUser = { username };
            
            showStatus(loginResult, 'Login successful!', 'success');
            socket.emit('setUsername', username);
            
            // Enable features
            joinChannelBtn.disabled = false;
            fileUploadForm.querySelector('button').disabled = false;
            
            // Hide login form
            document.getElementById('loginCard').style.display = 'none';
          } else {
            showStatus(loginResult, `Error: ${data.error}`, 'danger');
          }
        } catch (err) {
          showStatus(loginResult, `Error: ${err.message}`, 'danger');
        } finally {
          loginButton.disabled = false;
        }
      });

      // Message sending
      messageInput.addEventListener('input', () => {
        sendMessageBtn.disabled = !messageInput.value.trim() || !currentRoom;
      });

      sendMessageBtn.addEventListener('click', () => {
        const text = messageInput.value.trim();
        if (!text || !currentRoom) return;

        const msgObject = {
          room: currentRoom,
          username: currentUser?.username || 'Guest',
          text
        };

        socket.emit('sendRoomMessage', msgObject);
        messageInput.value = '';
        sendMessageBtn.disabled = true;
      });

      // Channel joining
      joinChannelBtn.addEventListener('click', () => {
        const roomName = channelInput.value.trim();
        if (!roomName) return;

        socket.emit('joinRoom', roomName);
        currentRoom = roomName;
        currentChannelEl.textContent = `Current channel: ${roomName}`;
        channelInput.value = '';
        sendMessageBtn.disabled = !messageInput.value.trim();
      });

      // File upload handler
      fileUploadForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const fileInput = document.getElementById('fileInput');
        const file = fileInput.files[0];
        
        if (!file) return;

        const uploadButton = fileUploadForm.querySelector('button');
        uploadButton.disabled = true;

        const formData = new FormData();
        formData.append('file', file);

        try {
          const response = await fetch('/upload', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${authToken}`
            },
            body: formData
          });

          const data = await response.json();

          if (response.ok) {
            showStatus(uploadStatus, 'File uploaded successfully!', 'success');
            
            // Add file to list
            const li = document.createElement('li');
            li.className = 'list-group-item';
            const link = document.createElement('a');
            link.href = data.filePath;
            link.textContent = data.filename;
            link.target = '_blank';
            li.appendChild(link);
            filesList.appendChild(li);
            
            fileInput.value = '';
          } else {
            showStatus(uploadStatus, `Upload failed: ${data.error}`, 'danger');
          }
        } catch (err) {
          showStatus(uploadStatus, `Upload error: ${err.message}`, 'danger');
        } finally {
          uploadButton.disabled = false;
        }
      });

      // Message handlers
      socket.on('roomMessage', (data) => {
        appendMessage(`[${data.room}] ${data.username}: ${data.text}`);
      });

      socket.on('privateMessage', (data) => {
        // If we have a private chat open with this sender, add to that
        if (currentPrivateChat) {
          appendPrivateMessage(`${data.sender}: ${data.text}`);
        } else {
          // Otherwise add to main chat log
          appendMessage(`[PM from ${data.sender}]: ${data.text}`);
        }
      });

      // Online users handler
      socket.on('onlineUsers', (usernames) => {
        const onlineList = document.getElementById('onlineUsersList');
        onlineList.innerHTML = '';
        usernames.forEach((username) => {
          const li = document.createElement('li');
          li.className = 'list-group-item cursor-pointer';
          li.textContent = username;
          
          // Add click handler for private messaging
          if (username !== currentUser?.username) {
            li.style.cursor = 'pointer';
            li.addEventListener('click', () => startPrivateMessage(username));
          } else {
            li.classList.add('bg-light');
          }
          
          onlineList.appendChild(li);
        });
      });

      // Private messaging handlers
      const startPrivateMessageBtn = document.getElementById('startPrivateMessageBtn');
      const privateMessageUser = document.getElementById('privateMessageUser');
      const privateMessageStatus = document.getElementById('privateMessageStatus');

      privateMessageUser.addEventListener('input', () => {
        startPrivateMessageBtn.disabled = !privateMessageUser.value.trim() || 
                                        privateMessageUser.value.trim() === currentUser?.username;
      });

      // Private chat state
      let currentPrivateChat = null;

      function startPrivateMessage(targetUser) {
        if (!currentUser) {
          showStatus(privateMessageStatus, 'Please login first', 'danger');
          return;
        }

        if (targetUser === currentUser.username) {
          showStatus(privateMessageStatus, 'Cannot message yourself', 'warning');
          return;
        }

        socket.emit('startPrivateMessage', { targetUser }, (response) => {
          if (response.error) {
            showStatus(privateMessageStatus, `Error: ${response.error}`, 'danger');
          } else {
            // Show private chat interface
            document.getElementById('privateChatInterface').style.display = 'block';
            document.getElementById('startPrivateChatInterface').style.display = 'none';
            document.getElementById('privateChatHeader').textContent = `Chat with: ${targetUser}`;
            document.getElementById('privateChatLog').innerHTML = ''; // Clear previous chat
            
            // Set current private chat state
            currentPrivateChat = {
              room: response.room,
              targetUser: targetUser
            };
            
            privateMessageUser.value = '';
            startPrivateMessageBtn.disabled = true;
          }
        });
      }

      // Handle private chat interface
      const privateChatLog = document.getElementById('privateChatLog');
      const privateMessageInput = document.getElementById('privateMessageInput');
      const sendPrivateMessageBtn = document.getElementById('sendPrivateMessageBtn');
      const closePrivateChatBtn = document.getElementById('closePrivateChat');

      sendPrivateMessageBtn.addEventListener('click', () => {
        const text = privateMessageInput.value.trim();
        if (!text || !currentPrivateChat) return;

        socket.emit('sendPrivateMessage', {
          room: currentPrivateChat.room,
          text: text
        });
        
        // Add message to chat log immediately
        appendPrivateMessage(`You: ${text}`);
        privateMessageInput.value = '';
      });

      privateMessageInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          sendPrivateMessageBtn.click();
        }
      });

      closePrivateChatBtn.addEventListener('click', () => {
        document.getElementById('privateChatInterface').style.display = 'none';
        document.getElementById('startPrivateChatInterface').style.display = 'block';
        currentPrivateChat = null;
      });

      function appendPrivateMessage(message) {
        const p = document.createElement('p');
        p.textContent = message;
        p.className = 'mb-1';
        privateChatLog.appendChild(p);
        privateChatLog.scrollTop = privateChatLog.scrollHeight;
      }

      startPrivateMessageBtn.addEventListener('click', () => {
        const targetUser = privateMessageUser.value.trim();
        startPrivateMessage(targetUser);
      });

      // New file notification handler
      socket.on('newFile', (fileData) => {
        appendMessage(`${fileData.uploader} uploaded: ${fileData.filename}`);
      });
    </script>
  </body>
</html>








